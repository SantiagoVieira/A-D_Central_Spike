# -*- coding: utf-8 -*-
"""Analisis-taller1

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TAthK9EXKfwp4m9SKdhHLIEwoU-hruiA

1. Dado las dimensiones de una matriz cuadrada, mostrar los
índices de la matriz en forma de zig-zag empezando por la
posición[n][n].(Punto recursivo)
"""

def m_zig_zag(m,row = 0, col = 0, indices = [[0,0]], mov = 0):

  if row == (len(m)-1) and col == (len(m)-1):                                   # caso base
    return indices

  else:

    if mov ==1:                                                                 # movimiento en diagonal derecha arriba
      if row - 1 >= 0 and col + 1 <= (len(m)-1):                                # pregunto si me puedo mover en esa dirrecion
        n = [row - 1,col + 1]                                                   # n variable que guarda los indices de la posicion

        if n not in indices:                                                    # pregunto si no esta en la lista de los indices para no repitir posiciones
          indices.append([row -1, col + 1])
          return m_zig_zag(m,row - 1, col + 1, indices, mov = 2 )               # llamo al otro movimiento cambiando row y col a la posicion que queria que se moviera.

      if row == 0 and col + 1 <= (len(m)-1):                                    # por si se tiene que mover a la derecha, estando en la primera fila

        return m_zig_zag(m,row,col,indices,mov = 3)

      if row == 0 and col == (len(m)-1):                                        # por si se tiene que mover abajo, estando en la primera fila y ultima columna
        return m_zig_zag(m,row,col,indices,mov = 0)

      if row == (len(m) -1 ) and col + 1 <= (len(m) -1 ):                       # por si se tiene que mover a la derecha, estando en la ultima fila
        return m_zig_zag(m,row,col,indices,mov = 3)

      else:
        return m_zig_zag(m,row,col,indices,mov = 2)                             # llamo al otro moviento

    if mov ==2:                                                                 # moviento diagonal izquierda abajo
      if row + 1 <= (len(m)-1) and col - 1 >= 0:                                # pregunto si me puedo mover en esa dirrecion

        n = [row + 1,col - 1]                                                   # n variable que guarda los indices de la posicion

        if n not in indices:
          indices.append([row +1, col - 1])
          return m_zig_zag(m,row + 1, col - 1, indices, mov = 1 )

      if row <= (len(m) - 1) and col == 0:                                      # por si se tiene que mover hacia abajo, estando en cualquier fila pero en la primera colunma
        return m_zig_zag(m,row,col,indices,mov = 0)

      if row <= (len(m) - 1) and col == (len(m) - 1):                           # por si se tiene que mover hacia abajo, estando en cualquier fila pero en la ultima colunma
        return m_zig_zag(m,row,col,indices,mov = 0)

      else:

        return m_zig_zag(m,row,col,indices,mov = 1)

    if mov == 3:                                                                # moviento hacia la derecha
      if row <= (len(m) - 1) and col + 1 <= (len(m)-1):
        n = [row,col + 1]
        if n not in indices:
          indices.append([row,col+1])
          return m_zig_zag(m,row,col + 1,indices,mov = 2)                       # pongo mov = 2 para que se siga moviendo en zig zag
      else:
        return m_zig_zag(m,row,col,indices,mov = 2)

    if mov == 0:                                                                # movimiento hacia abajo

      if row + 1 <= (len(m)-1) and col <= (len(m)-1):

       # n = [row + 1, col]
        if [row + 1, col] not in indices:
          indices.append([row + 1, col])
          return m_zig_zag(m,row + 1, col, indices, mov = 1)
      else:
        return m_zig_zag(m,row,col,indices,mov = 1)                             # pongo mov = 1 para que se siga moviendo en zig zag

# Casos de Prueba
b = [[2,3,4],[3,6,1],[0,6,5]] # matriz 3 x 3
m = [[2,8,6,0],[12,8,9,4],[5,7,0,2],[0,3,1,6]] # matriz 4 x 4
c = [[2,6,1,0,5],[7,9,2,5,7],[5,1,0,3,8],[4,1,7,0,0],[7,4,3,1,0]] # matriz 5 x 5
n = [[2,8,6,0,7,8],[2,8,6,0,7,8],[2,8,6,0,7,8],[2,8,6,0,7,8],[2,8,6,0,7,8],[2,8,6,0,7,8]] # matriz 6 x 6
m_zig_zag(m)

""" crea una funcion recursiva que sume todos los elementos de un array (punto recursivo)"""

def sum_array(array):
    if len(array) == 0:                            #Verificamos si el array esta vacio, si lo esta retorna 0
        return 0
    else:
        return array[0] + sum_array(array[1:])     # Si el array no está vacío, devuelve el primer elemento del array sumado al resultado de llamar a la función sum_array con el resto del array (desde el segundo elemento en adelante).

# caso de prueba
array = [1, 2, 3, 4, 10]
print(sum_array(array))

"""Desarrolla una función no recursiva que sume todos los dígitos
de un número entero.
"""

def add_numbers(numbers):  # Complejidad temporal: O(n), Complejidad espacial: O(1)
    numbers = abs(numbers)  # Operación constante, O(1)
    sum = 0  # Operación constante, O(1)
    while numbers != 0:  # Iteración sobre los dígitos, O(n)
        sum += numbers % 10  # Operación constante, O(1)
        numbers //= 10  # Operación constante, O(1)
    return sum  # Operación constante, O(1)

numbers = 78956424874  # Operación constante, O(1)
print("La suma de los dígitos de", numbers, "es:", add_numbers(numbers))  # Operación constante, O(1)

"""Implementa una función no recursiva que cuente el número de
dígitos en un número entero
"""

def contar_digitos(numero): # Complejidad temporal: O(n), Complejidad espacial: O(1)
    # Convertimos el número a su valor absoluto para manejar números negativos
    numero = abs(numero) #O(0)
    # Inicializamos el contador de dígitos
    contador = 0 #O(0)
    # Iteramos mientras el número no sea igual a cero
    while numero != 0: #O(n)
        # Incrementamos el contador en uno
        contador += 1 #O(n)
        # Dividimos el número entre 10 para eliminar el último dígito
        numero //= 10 #O(n)
    # Retornamos el contador que representa el número de dígitos
    return contador #O(0)

# Ejemplo de uso
numero = 102485 #O(0)
print("El número de dígitos en", numero, "es:", contar_digitos(numero)) #O(0)